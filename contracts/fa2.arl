archetype fa2

/* enum & record types ------------------------------------------------------- */

enum operator_transfer_policy =
| No_transfer
| Owner_transfer
| Owner_or_operator_transfer (* default *)

enum owner_hook_policy =
| Owner_no_hook              (* default *)
| Optional_owner_hook
| Required_owner_hook

record basic_permissions {
  transfer_policy      : operator_transfer_policy;
  sender_hook_policy   : owner_hook_policy;
  receiver_hook_policy : owner_hook_policy;
}

record custom_policy {
  tag        : string;
  config_api : option<address>;
}

record permissions {
  basic                : basic_permissions;
  custom               : option<custom_policy>;
}

/* Hook paramter : transfer descriptor */

record transfer_destination_descriptor {
  to_desc            : option<address>;
  token_id_desc      : nat;
  token_amount_desc  : nat;
}

record transfer_descriptor {
  from_  : option<address>;
  txs    : list<transfer_destination_descriptor>;
}

record transfer_descriptor_param {
  batch          : list<transfer_descriptor>;
  operator_p     : address;
}

/* transfer argument type */

record transfer_destination {
  %to          : address;
  token_id     : nat;
  token_amount : nat
}

enum owner_type =
| Sender
| Receiver

/* getBalance operator argument type */

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
}

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
}

/* update_operator argument type */

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
}

/* STORAGE ------------------------------------------------------------------ */

variable admin : address = @tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg

variable permissions_descriptor : permissions = {
  {
    No_transfer;
    Owner_no_hook;
    Owner_no_hook
  };
  none<custom_policy>
}

asset ledger identified by token owner to big_map {
  token  : nat;
  owner  : address;
  amount : nat = 0;
  hook   : option<address> = none;
}

asset operator identified by op_addr op_token_id op_owner_addr to big_map {
  op_addr       : address;
  op_token_id   : nat;
  op_owner_addr : address;
}

asset tokens {
  id : nat;
  permissions_desc : basic_permissions;
}

/* utils function ------------------------------------------------------------- */

function get_transfer_policy (tid : nat) : operator_transfer_policy {
  return
    match_option permissions_descriptor.custom with // check custom policy
    | some(cust) ->
      if cust.tag = "FA2_PER_TOKEN" then begin // look up in tokens
        tokens[tid].permissions_desc.transfer_policy
      end else begin // fall back to default
        permissions_descriptor.basic.transfer_policy
      end
    | none -> // no custom, get default
      permissions_descriptor.basic.transfer_policy
    end
}

function get_hook_policy (tid : nat, ot : owner_type) : owner_hook_policy {
  return
    match_option permissions_descriptor.custom with // check custom policy
    | some(cust) ->
      if cust.tag = "FA2_PER_TOKEN" then begin // look up in tokens
        match ot with
        | Sender   ->  tokens[tid].permissions_desc.sender_hook_policy
        | Receiver ->  tokens[tid].permissions_desc.receiver_hook_policy
        end
      end else begin // fall back to default
        match ot with
        | Sender   ->  permissions_descriptor.basic.sender_hook_policy
        | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
        end
      end
    | none -> // fall back to default
      match ot with
      | Sender   ->  permissions_descriptor.basic.sender_hook_policy
      | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
      end
    end
}

function apply_transfer_policy (otp : operator_transfer_policy, %from : address, tr : transfer_destination) : option<string> {
  return
    match otp with
    | No_transfer ->
      if caller = admin then
        none<string>
      else
        some("FA2_TX_DENIED")
    | Owner_transfer ->
      if caller = %from and ledger.contains((tr.token_id, %from)) then
        none<string>
      else
        some("FA2_NOT_OWNER")
    | Owner_or_operator_transfer ->
      if (%caller = %from and ledger.contains((tr.token_id, %from))) or
      operator.contains((caller,tr.token_id,%from)) then
        none<string>
      else
        some("FA2_NOT_OPERATOR")
    end
}

function mk_op (
  a           : address,
  tp          : transfer_descriptor_param,
  ot          : owner_type) : or<option<operation>,string> {
  var e =
    match ot with
    | Sender   -> entrypoint<transfer_descriptor_param>("%fa2_token_sender",a)
    | Receiver -> entrypoint<transfer_descriptor_param>("%fa2_token_receiver", a)
    end;
  return left<_,string>(some(mkoperation(0tz, opt_get(e), tp)))
}

function apply_hook (
  itoken_id   : nat,
  iowner      : address,
  tp          : transfer_descriptor_param,
  ot          : owner_type) : or<option<operation>,string> {
  var v_owner_hook_policy =
    match_option permissions_descriptor.custom with // check custom policy
    | some(cust) ->
      if cust.tag = "FA2_PER_TOKEN" then begin // look up in tokens
        match ot with
        | Sender   ->  tokens[itoken_id].permissions_desc.sender_hook_policy
        | Receiver ->  tokens[itoken_id].permissions_desc.receiver_hook_policy
        end
      end else begin // fall back to default
        match ot with
        | Sender   ->  permissions_descriptor.basic.sender_hook_policy
        | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
        end
      end
    | none -> // fall back to default
      match ot with
      | Sender   ->  permissions_descriptor.basic.sender_hook_policy
      | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
      end
    end;
  return
    // match get_hook_policy(itoken_id, ot) with
    match v_owner_hook_policy with
    | Owner_no_hook -> left<_,string>(none<operation>)
    | Optional_owner_hook -> begin
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> mk_op (h, tp, ot)
      | none -> left<_,string>(none<operation>)
      end
    end
    | Required_owner_hook ->
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> mk_op (h, tp, ot)
      | none -> right<option<operation>, _>("FA2_HOOK_NOT_SET")
      end
    end
}

function is_per_token () : bool {
  return match_option permissions_descriptor.custom with // check custom policy
    | some(c) -> if c.tag = "FA2_PER_TOKEN" then true else false
    | none -> false
  end
}

function get_hook_param(c : address, f : address, tds : list<transfer_destination>) : transfer_descriptor_param {
  return { [ {
    from_ = some(f);
    txs = map(tds, td -> {
      to_desc            = some(td.%to);
      token_id_desc      = td.token_id;
      token_amount_desc  = td.token_amount
    })}]; c
  }
}

/* entry points -------------------------------------------------------------- */

entry add_token (
  new_token_id : nat,
  totalsupply  : nat,
  owner_hook   : option<address>,
  perms        : basic_permissions) {
  failif {
    f0 : tokens.contains(new_token_id);
  }
  effect {
    ledger.add ({ new_token_id; caller; totalsupply; owner_hook });
    tokens.add ({ new_token_id; perms });
  }
}

entry set_hook (ti : nat, h : option<address>) {
  // if only 'update', it is impossble to set the hook if no token is possessed ...
  // how to prove that it is impossible not to set the hook ?
  // no fail and valid postcondition ?
  ledger.addupdate ((ti, caller), { hook = h });
}

entry %transfer(%from : address, tds : list<transfer_destination>) {
  var applied_hooks : set<address * nat> = []; // do not apply hook twice
  var hook_param = get_hook_param(caller, %from, tds);
  for td in tds do
    var applied_hook_id = if is_per_token() then td.token_id else 0;
    var transfer_p = get_transfer_policy(td.token_id);
    match_option apply_transfer_policy(transfer_p, %from, td) with
    | some(msg) -> fail(msg)
    | none -> begin
        /* basic checks ----------------------------------------------------- */
        dorequire(tokens.contains(td.token_id), "FA2_TOKEN_UNDEFINED");
        dorequire(ledger[(td.token_id, %from)].amount >= td.token_amount, "FA2_INSUFFICIENT_BALANCE");
        /* apply sender hook ------------------------------------------------ */
        if not contains(applied_hooks, (%from, applied_hook_id)) then begin
          match_or apply_hook(td.token_id, %from, hook_param, Sender) with
          | left(sop) -> match_option sop with
            | some (op) -> operations := prepend(operations, op)
            | none -> ()
            end
          | right(msg) -> fail (msg)
          end;
          applied_hooks := add(applied_hooks, (%from, applied_hook_id));
        end;
        /* apply receiver hook ---------------------------------------------- */
        if not contains(applied_hooks, (td.%to, applied_hook_id)) then begin
          match_or apply_hook(td.token_id, td.%to, hook_param, Receiver) with
          | left(sop) -> match_option sop with
            | some (op) -> operations := prepend(operations, op)
            | none -> ()
            end
          | right(msg) -> fail (msg)
          end;
          applied_hooks := add(applied_hooks, (td.%to, applied_hook_id));
        end;
        /* update ledger ---------------------------------------------------- */
        ledger.update((td.token_id, %from), { amount -= td.token_amount });
        ledger.addupdate((td.token_id, td.%to), { amount += td.token_amount });
      end
    end
  done
}

getter balance_of (brs : list<balance_of_request>) : list<balance_of_response> {
  return map(brs, br -> {
    request = br;
    balance_ = (if ledger.contains((br.btoken_id,br.bo_owner))
                then ledger[(br.btoken_id,br.bo_owner)].amount
                else 0)
  })
}

entry update_operators (upl : list<or<operator_param, operator_param>>) {
  for up in upl do
    match_or up with
    | left(param) -> // add
      operator.add({ param.opp_operator; param.opp_token_id; param.opp_owner })
    | right(param) -> // remove
      operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
    end;
  done;
}
