archetype fa2

variable admin : address = @tz1

enum operator_transfer_policy =
| No_transfer
| Owner_transfer
| Owner_or_operator_transfer (* default *)

enum owner_hook_policy =
| Owner_no_hook              (* default *)
| Optional_owner_hook
| Required_owner_hook

/* variable permissions_descriptor : operator_transfer_policy * owner_hook_policy * owner_hook_policy
    = (Owner_or_operator_transfer, Owner_no_hook, Owner_no_hook) */

asset tokens {
  id : nat;
  permissions_desc : operator_transfer_policy * owner_hook_policy * owner_hook_policy;
}

record transfer_destination_descriptor {
  to_desc            : option<address>;
  token_id_desc      : nat;
  token_amount_desc  : nat;
}

record transfer_descriptor {
  from_  : option<address>;
  txs    : list<transfer_destination_descriptor>;
}

record transfer_descriptor_param {
  batch          : list<transfer_descriptor>;
  operator_p     : address;
}

asset ledger identified by token owner to big_map {
  token  : nat;
  owner  : address;
  amount : nat = 0;
  hook   : option<contract<transfer_descriptor_param>> = none;
}

asset operator identified by op_addr op_token_id op_owner_addr to big_map {
  op_addr       : address;
  op_token_id   : nat;
  op_owner_addr : address;
}

record transfer_destination {
  %to          : address;
  token_id     : nat;
  token_amount : nat
}


function apply_transfer_policy (%from : address, tr : transfer_destination) : option<string> {
  var res : option<string> =
    match tokens[tr.token_id].permissions_desc[0] with
    | No_transfer ->
      if caller = admin then
        none<string>
      else
        some("FA2_TX_DENIED")
    | Owner_transfer ->
      if caller = %from and ledger.contains((tr.token_id, %from)) then
        none<string>
      else
        some("FA2_NOT_OWNER")
    | Owner_or_operator_transfer ->
      if (%caller = %from and ledger.contains((tr.token_id, %from))) or
      operator.contains((caller,tr.token_id,%from)) then
        none<string>
      else
        some("FA2_NOT_OPERATOR")
    end;
  return res
}

entry add_token (
  new_token_id : nat,
  totalsupply  : nat,
  owner_hook   : option<contract<transfer_descriptor_param>>,
  permissions  : operator_transfer_policy * owner_hook_policy * owner_hook_policy) {
  failif {
    f0 : tokens.contains(new_token_id);
  }
  effect {
    ledger.add ({ new_token_id; caller; totalsupply; owner_hook });
    tokens.add ({ new_token_id; permissions });
  }
}

entry set_hook (ti : nat, h : option<contract<transfer_descriptor_param>>) {
  // if only 'update', it is impossble to set the hook if no token is possessed ...
  // how to prove that it is impossible not to set the hook ?
  // no fail and valid postcondition ?
  ledger.addupdate ((ti, caller), { hook = h });
}

function apply_hook (
  itoken_id    : nat,
  iowner       : address,
  tp          : transfer_descriptor_param,
  hook_policy : owner_hook_policy) : or<option<operation>,string> {
  return
    (match hook_policy with
    | Owner_no_hook -> left<_,string>(none<operation>)
    | Optional_owner_hook -> begin
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> left<_,string>(some(mkoperation(0tz,h,tp)))
      | none -> left<_,string>(none<operation>)
      end
    end
    | Required_owner_hook ->
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> left<_,string>(some(mkoperation(0tz,h,tp)))
      | none -> right<option<operation>, _>("FA2_HOOK_NOT_SET")
      end
    end)
}

entry %transfer(%from : address, tds : list<transfer_destination>) {
  var hook_applied_for : set<bool> = [];
  var transfer_param = get_transfer_param(%from, tds);
  match_or (apply_hook(%from, transfer_param)) with
  | left(sop) -> begin
      match_option sop with
      | some (op) -> operations := prepend(operations, op)
      | none -> ()
      end
    end
  | right(msg) -> fail (msg)
  end;
  for td in tds do
    match_option apply_transfer_policy(%from, td) with
    | some(msg) -> fail(msg)
    | none -> begin
        dorequire(tokens.contains(td.token_id), "FA2_TOKEN_UNDEFINED");
        dorequire(ledger[(td.token_id, %from)].amount >= td.token_amount, "FA2_INSUFFICIENT_BALANCE");
        operations := prepend(operations, apply_hook(td.%to, transfer_param));
        ledger.update((td.token_id, %from), { amount -= td.token_amount });
        ledger.addupdate((td.token_id, td.%to), { amount += td.token_amount });
      end
    end
  done
}

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
}

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
}

getter balance_of (brs : list<balance_of_request>) : list<balance_of_response> {
  return map(brs, br -> {
    request = br;
    balance_ = (if ledger.contains((br.btoken_id,br.bo_owner))
                then ledger[(br.btoken_id,br.bo_owner)].amount
                else 0)
  })
}

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
}

entry update_operators (upl : list<or<operator_param, operator_param>>) {
  for up in upl do
    match_or up with
    | left(param) -> // add
      operator.add({ param.opp_operator; param.opp_token_id; param.opp_owner })
    | right(param) -> // remove
      operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
    end;
  done;
}
