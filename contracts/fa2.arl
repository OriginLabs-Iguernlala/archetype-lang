archetype fa2

/* TYPES ---------------------------------------------------------------- */

enum token_type =
| FT
| FA1_2
| NFT

enum operator_transfer_policy =
| No_transfer
| Owner_transfer
| Owner_or_operator_transfer (* default *)

enum owner_hook_policy =
| Owner_no_hook              (* default *)
| Optional_owner_hook
| Required_owner_hook

record basic_permissions {
  transfer_policy      : operator_transfer_policy;
  sender_hook_policy   : owner_hook_policy;
  receiver_hook_policy : owner_hook_policy;
}

record custom_policy {
  tag        : string;
  config_api : option<address>;
}

record permissions {
  basic                : basic_permissions;
  custom               : option<custom_policy>;
}

/* Hook paramter : transfer descriptor */

record transfer_destination_descriptor {
  to_desc            : option<address>;
  token_id_desc      : nat;
  token_amount_desc  : nat;
}

record transfer_descriptor {
  from_  : option<address>;
  txs    : list<transfer_destination_descriptor>;
}

record transfer_descriptor_param {
  batch          : list<transfer_descriptor>;
  operator_p     : address;
}

/* transfer argument type */

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
}

enum owner_type =
| Sender
| Receiver

/* getBalance operator argument type */

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
}

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
}

/* update_operator argument type */

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
}

/* STORAGE ------------------------------------------------------------------ */

variable admin : address = @tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg

variable permissions_descriptor : permissions = {
  {
    No_transfer;
    Owner_no_hook;
    Owner_no_hook
  };
  none<custom_policy>
}

asset ledger identified by token_id owner to big_map {
  token_id  : nat;
  owner     : address;
  amount    : nat = 0;
  hook      : option<address> = none;
}

asset operator identified by op_addr op_token_id op_owner_addr to big_map {
  op_addr       : address;
  op_token_id   : nat;
  op_owner_addr : address;
}

asset token {
  id               : nat;
  token_typ        : token_type;
  permissions_desc : option<basic_permissions>;
}

asset allowance identified by addr_owner allowed_spender allowed_token_id to big_map {
  addr_owner         : address;
  allowed_spender    : address;
  allowed_token_id   : nat;
  allowed_amount     : nat;
}

/* UTIL FUNCTIONS -------------------------------------------------------------- */

function get_transfer_policy (tid : nat) : operator_transfer_policy {
  return
    match_option permissions_descriptor.custom with // check custom policy
    | some(cust) ->
      if cust.tag = "FA2_PER_TOKEN" then begin // look up in tokens
        match_option token[tid].permissions_desc with
        | some(pd) -> pd.transfer_policy
        | none -> permissions_descriptor.basic.transfer_policy
        end
      end else begin // fall back to default
        permissions_descriptor.basic.transfer_policy
      end
    | none -> // no custom, get default
      permissions_descriptor.basic.transfer_policy
    end
}

function get_hook_policy (tid : nat, ot : owner_type) : owner_hook_policy {
  return
    match_option permissions_descriptor.custom with // check custom policy
    | some(cust) ->
      if cust.tag = "FA2_PER_TOKEN" then begin // look up in tokens
        match ot with
        | Sender   ->  match_option token[tid].permissions_desc with
          | some(pd) -> pd.sender_hook_policy
          | none -> permissions_descriptor.basic.sender_hook_policy
          end
        | Receiver ->  match_option token[tid].permissions_desc with
          | some(pd) -> pd.receiver_hook_policy
          | none -> permissions_descriptor.basic.receiver_hook_policy
          end
        end
      end else begin // fall back to default
        match ot with
        | Sender   ->  permissions_descriptor.basic.sender_hook_policy
        | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
        end
      end
    | none -> // fall back to default
      match ot with
      | Sender   ->  permissions_descriptor.basic.sender_hook_policy
      | Receiver ->  permissions_descriptor.basic.receiver_hook_policy
      end
    end
}

function apply_transfer_policy (
  otp   : operator_transfer_policy,
  %from : address,
  tr    : transfer_destination) : option<string> {
  return
    match otp with
    | No_transfer ->
      if caller = admin then
        none<string>
      else
        some("FA2_TX_DENIED")
    | Owner_transfer ->
      if caller = %from and ledger.contains((tr.token_id_dest, %from)) then
        none<string>
      else
        some("FA2_NOT_OWNER")
    | Owner_or_operator_transfer ->
      if (%caller = %from and ledger.contains((tr.token_id_dest, %from))) or
      operator.contains((caller,tr.token_id_dest,%from)) then
        none<string>
      else
        some("FA2_NOT_OPERATOR")
    end
}

function mk_op (
  a           : address,
  tp          : transfer_descriptor_param,
  ot          : owner_type) : or<option<operation>,string> {
  var e =
    match ot with
    | Sender   -> entrypoint<transfer_descriptor_param>("%fa2_token_sender",a)
    | Receiver -> entrypoint<transfer_descriptor_param>("%fa2_token_receiver", a)
    end;
  return left<_,string>(some(mkoperation(0tz, opt_get(e), tp)))
}

function apply_hook (
  itoken_id   : nat,
  iowner      : address,
  tp          : transfer_descriptor_param,
  ot          : owner_type) : or<option<operation>,string> {
  return
    match get_hook_policy(itoken_id, ot) with
    | Owner_no_hook -> left<_,string>(none<operation>)
    | Optional_owner_hook -> begin
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> mk_op (h, tp, ot)
      | none -> left<_,string>(none<operation>)
      end
    end
    | Required_owner_hook ->
      match_option ledger[(itoken_id, iowner)].hook with
      | some(h) -> mk_op (h, tp, ot)
      | none ->
        right<option<operation>, _> (match ot with
          | Sender   -> "FA2_SENDER_HOOK_UNDEFINED"
          | Receiver -> "FA2_RECEIVER_HOOK_UNDEFINED"
          end)
      end
    end
}

function is_per_token () : bool {
  return match_option permissions_descriptor.custom with // check custom policy
    | some(c) -> if c.tag = "FA2_PER_TOKEN" then true else false
    | none -> false
  end
}

function get_hook_param(c : address, f : address, tds : list<transfer_destination>) : transfer_descriptor_param {
  return { [ {
    from_ = some(f);
    txs = map(tds, td -> {
      to_desc            = some(td.to_dest);
      token_id_desc      = td.token_id_dest;
      token_amount_desc  = td.token_amount_dest
    })}]; c
  }
}

function get_update_param (up : or<operator_param, operator_param>) : operator_param {
  return
    match_or up with
    | left(param) -> param
    | right(param) -> param
    end
}

function get_amount (itoken_id : nat, iamount : nat) : nat {
  return
    match token[itoken_id].token_typ with
    | FT    -> iamount
    | FA1_2 -> iamount
    | NFT   -> if iamount > 0 then 1 else 0
    end
}

/* ENTRY POINTS -------------------------------------------------------------- */

entry add_token (
  new_token_id           : nat,
  new_token_type         : token_type,
  totalsupply            : nat,
  new_owner              : address,
  owner_hook             : option<address>,
  new_token_permissions  : option<basic_permissions>) {
  called by admin
  failif {
    f0 : token.contains(new_token_id);
    f1 : new_token_type = NFT and totalsupply <> 1
  }
  effect {
    token.add ({ new_token_id; new_token_type; new_token_permissions });
    ledger.add ({ new_token_id; new_owner; totalsupply; owner_hook });
  }
}

entry set_hook (ti : nat, h : option<address>) {
  // if only 'update', it is impossble to set the hook if no token is possessed ...
  // how to prove that it is impossible not to set the hook ?
  // no fail and valid postcondition ?
  ledger.addupdate ((ti, caller), { hook = h });
}

entry %transfer(%from : address, tds : list<transfer_destination>) {
  var applied_hooks : set<address * nat> = []; // do not apply hook twice
  var hook_param = get_hook_param(caller, %from, tds);
  for td in tds do
    var transfer_amount = get_amount(td.token_id_dest, td.token_amount_dest);
    var applied_hook_id = if is_per_token() then td.token_id_dest else 0;
    var transfer_p = get_transfer_policy(td.token_id_dest);
    match_option apply_transfer_policy(transfer_p, %from, td) with
    | some(msg) -> fail(msg)
    | none -> begin
        /* basic checks ----------------------------------------------------- */
        dorequire(token.contains(td.token_id_dest), "FA2_TOKEN_UNDEFINED");
        dorequire(ledger[(td.token_id_dest, %from)].amount >= transfer_amount, "FA2_INSUFFICIENT_BALANCE");
        /* apply sender hook ------------------------------------------------ */
        if not contains(applied_hooks, (%from, applied_hook_id)) then begin
          match_or apply_hook(td.token_id_dest, %from, hook_param, Sender) with
          | left(sop) -> match_option sop with
            | some (op) -> operations := prepend(operations, op)
            | none -> ()
            end
          | right(msg) -> fail (msg)
          end;
          applied_hooks := add(applied_hooks, (%from, applied_hook_id));
        end;
        /* apply receiver hook ---------------------------------------------- */
        if not contains(applied_hooks, (td.to_dest, applied_hook_id)) then begin
          match_or apply_hook(td.token_id_dest, td.%to_dest, hook_param, Receiver) with
          | left(sop) -> match_option sop with
            | some (op) -> operations := prepend(operations, op)
            | none -> ()
            end
          | right(msg) -> fail (msg)
          end;
          applied_hooks := add(applied_hooks, (td.to_dest, applied_hook_id));
        end;
        /* check allowance for FA 1.2 --------------------------------------- */
        if token[td.token_id_dest].token_typ = FA1_2 then begin
          if caller <> %from then begin
            var current = allowance[(%from, caller,td.token_id_dest)].allowed_amount;
            dofailif(current < transfer_amount, ("NotEnoughAllowance", ((transfer_amount, current))));
            allowance.update((%from, caller, td.token_id_dest), { allowed_amount -=  transfer_amount });
          end;
        end;
        /* update ledger ---------------------------------------------------- */
        ledger.update((td.token_id_dest, %from), { amount -= transfer_amount });
        ledger.addupdate((td.token_id_dest, td.to_dest), { amount += transfer_amount });
      end
    end
  done
}

getter balance_of (brs : list<balance_of_request>) : list<balance_of_response> {
  return map(brs, br -> {
    request = br;
    balance_ = (if ledger.contains((br.btoken_id,br.bo_owner))
                then ledger[(br.btoken_id,br.bo_owner)].amount
                else 0)
  })
}

entry update_operators (upl : list<or<operator_param, operator_param>>) {
  for up in upl do
    match get_transfer_policy(get_update_param(up).opp_token_id) with
    | No_transfer -> fail("FA2_OPERATORS_UNSUPPORTED")
    | Owner_transfer -> fail("FA2_OPERATORS_UNSUPPORTED")
    | Owner_or_operator_transfer -> ()
    end;
    match_or up with
    | left(param) -> // add
      operator.add({ param.opp_operator; param.opp_token_id; param.opp_owner })
    | right(param) -> // remove
      operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
    end;
  done;
}

entry approve (spender : address, value : nat, itoken_id : nat) {
  require {
    r1 otherwise "NOT_A_FA1_2" : token[itoken_id].token_typ = FA1_2
  }
  effect {
    match get_transfer_policy(itoken_id) with
    | No_transfer -> fail("FA2_OPERATORS_UNSUPPORTED")
    | Owner_transfer -> fail("FA2_OPERATORS_UNSUPPORTED")
    | Owner_or_operator_transfer -> ()
    end;
    var k = (caller, spender, itoken_id);
    if allowance.contains(k) then begin
      var previous = allowance[k].allowed_amount;
      dofailif(previous > 0 and value > 0, (("UnsafeAllowanceChange", previous)));
    end;
    allowance.addupdate( k, { allowed_amount = value });
  }
}
